/**
 * This ruleset enforces a strict user-ownership security model for a personal loan
 * management application.
 *
 * Core Philosophy:
 * All user data is private and can only be accessed by the authenticated owner.
 * There are no public collections or admin roles defined in this ruleset. The
 * security model is designed for maximum privacy and data isolation between users.
 *
 * Data Structure:
 * The data is organized hierarchically, with all loan-related information nested
 * under a specific user's data tree. The structure is `/users/{userId}/loans/{loanId}`,
 * with related data like payments, collateral, and agreements stored in subcollections
 * under each loan.
 *
 * Key Security Decisions:
 * - Path-Based Ownership: Authorization is determined entirely by the `userId`
 *   wildcard in the document path. A user can only access documents where the
 *   path's `userId` matches their own authenticated UID.
 * - No Public Data: There are no top-level collections accessible to everyone.
 *   This prevents anonymous access and inadvertent data exposure.
 * - Granular Permissions: Each collection explicitly defines rules for get, list,
 *   create, update, and delete to ensure no unintended access is granted.
 * - Prohibition of User Listing: It is not possible to list documents in the
 *   top-level `/users` collection, protecting user privacy.
 *
 * Denormalization for Authorization:
 * This ruleset leverages a path-based security model, which is the most efficient
 * way to handle ownership. By nesting all of a user's data under a path containing
 * their UID (e.g., `/users/{userId}/...`), we avoid the need for costly `get()`
 * calls to check ownership on related documents. All authorization decisions
 * are made instantly by inspecting the request path.
 *
 * Structural Segregation:
 * The data model is already well-segregated. All sensitive user data is contained
 * within the `/users/{userId}` data tree, completely separate from any potential
 * future public or administrative data collections. This simplifies rules and
 * enhances security.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for readability and reusability
    
    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }
    
    /**
     * Validates if the currently authenticated user is the owner of the
     * document based on the userId in the path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * For update and delete operations, ensures the user is the owner AND
     * that the document actually exists before allowing the operation.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    match /users/{userId} {
      
      /**
       * @description Secures a user's loan documents. Only the user who owns the
       *   data tree can read or write their own loan information.
       * @path /users/{userId}/loans/{loanId}
       * @allow (get) An authenticated user with UID 'user_abc' reads their own loan
       *   at `/users/user_abc/loans/loan_123`.
       * @deny (get) An authenticated user with UID 'user_xyz' tries to read a loan
       *   at `/users/user_abc/loans/loan_123`.
       * @principle Restricts access to a user's own data tree.
       */
      match /loans/{loanId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
        
        /**
         * @description Secures payment records for a specific loan. Access is inherited
         *   from the parent loan's ownership rules.
         * @path /users/{userId}/loans/{loanId}/payments/{paymentId}
         * @allow (create) User 'user_abc' creates a new payment document within their
         *   own loan at `/users/user_abc/loans/loan_123/payments/payment_456`.
         * @deny (list) User 'user_xyz' attempts to list payments under another user's
         *   loan at `/users/user_abc/loans/loan_123/payments`.
         * @principle Enforces document ownership for all subcollection operations.
         */
        match /payments/{paymentId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isExistingOwner(userId);
          allow delete: if isExistingOwner(userId);
        }
        
        /**
         * @description Secures collateral records for a specific loan. Access is
         *   inherited from the parent loan's ownership rules.
         * @path /users/{userId}/loans/{loanId}/collateral/{collateralId}
         * @allow (update) User 'user_abc' updates a collateral document within their
         *   own loan at `/users/user_abc/loans/loan_123/collateral/col_789`.
         * @deny (get) An anonymous user attempts to read a collateral document.
         * @principle Enforces document ownership for all subcollection operations.
         */
        match /collateral/{collateralId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isExistingOwner(userId);
          allow delete: if isExistingOwner(userId);
          
          /**
           * @description Secures documents related to a specific piece of collateral.
           *   Access is inherited from the parent loan's ownership rules.
           * @path /users/{userId}/loans/{loanId}/collateral/{collateralId}/documents/{documentId}
           * @allow (get) User 'user_abc' reads a document related to their collateral at
           *   `/users/user_abc/loans/loan_123/collateral/col_789/documents/doc_001`.
           * @deny (delete) User 'user_xyz' tries to delete another user's document.
           * @principle Enforces document ownership for deeply nested subcollections.
           */
          match /documents/{documentId} {
            allow get: if isOwner(userId);
            allow list: if isOwner(userId);
            allow create: if isOwner(userId);
            allow update: if isExistingOwner(userId);
            allow delete: if isExistingOwner(userId);
          }
        }
        
        /**
         * @description Secures guarantor records for a specific loan. Access is inherited
         *   from the parent loan's ownership rules.
         * @path /users/{userId}/loans/{loanId}/guarantors/{guarantorId}
         * @allow (list) User 'user_abc' lists all guarantors for their loan at
         *   `/users/user_abc/loans/loan_123/guarantors`.
         * @deny (create) User 'user_xyz' tries to add a guarantor to another user's loan.
         * @principle Enforces document ownership for all subcollection operations.
         */
        match /guarantors/{guarantorId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isExistingOwner(userId);
          allow delete: if isExistingOwner(userId);
        }
        
        /**
         * @description Secures loan agreement records for a specific loan. Access is
         *   inherited from the parent loan's ownership rules.
         * @path /users/{userId}/loans/{loanId}/loanAgreements/{loanAgreementId}
         * @allow (get) User 'user_abc' reads their loan agreement at
         *   `/users/user_abc/loans/loan_123/loanAgreements/la_abc`.
         * @deny (update) User 'user_xyz' tries to modify another user's loan agreement.
         * @principle Enforces document ownership for all subcollection operations.
         */
        match /loanAgreements/{loanAgreementId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isExistingOwner(userId);
          allow delete: if isExistingOwner(userId);
        }
      }
    }
  }
}